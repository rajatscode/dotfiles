#!/usr/bin/env bash

# agent - Multi-Agent Session Manager
# Manages parallel AI coding sessions using git worktrees with shared context
#
# Usage:
#   agent new <session-name> [--branch=<branch>] [--template=<template>]
#   agent list
#   agent switch <session-name>
#   agent context <session-name> [--edit]
#   agent sync <session-name>
#   agent close <session-name> [--delete-branch] [--archive]
#   agent share-context <from-session> <to-session> --file=<filename>
#   agent lock <session-name> <reason>
#   agent unlock <session-name>
#   agent current
#   agent help

set -euo pipefail

# ============================================================================
# Configuration
# ============================================================================

AGENT_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/agents"
AGENT_SESSIONS_DIR="$AGENT_CONFIG_DIR/sessions"
AGENT_CONTEXTS_DIR="$AGENT_CONFIG_DIR/contexts"
# Templates are stored in the dotfiles repo, not in the config directory
DOTFILES_DIR="${DOTFILES_DIR:-$HOME/.dotfiles}"
AGENT_TEMPLATES_DIR="$DOTFILES_DIR/templates/agents"
AGENT_CONFIG_FILE="$AGENT_CONFIG_DIR/config.yaml"

# Default configuration (can be overridden in config.yaml)
DEFAULT_TEMPLATE="feature"
WORKTREE_PREFIX="wt-"
AUTO_SYNC=true

# Colors
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
MAGENTA=$'\033[0;35m'
CYAN=$'\033[0;36m'
BOLD=$'\033[1m'
NC=$'\033[0m' # No Color

# ============================================================================
# Utility Functions
# ============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_step() {
    echo -e "${CYAN}â–¶${NC} $1"
}

die() {
    log_error "$1"
    exit 1
}

# Initialize agent directories
init_agent_dirs() {
    # Check if ~/.config exists and is not a directory
    local config_parent="${XDG_CONFIG_HOME:-$HOME/.config}"
    if [[ -e "$config_parent" && ! -d "$config_parent" ]]; then
        die "$config_parent exists but is not a directory. Please remove it or use XDG_CONFIG_HOME to specify a different location."
    fi

    # Helper function to create directory handling symlinks
    safe_mkdir() {
        local dir="$1"

        # If it's a broken symlink, resolve and create the target
        if [[ -L "$dir" && ! -e "$dir" ]]; then
            local target=$(readlink "$dir")
            # If target is relative, make it absolute
            if [[ "$target" != /* ]]; then
                target="$(dirname "$dir")/$target"
            fi
            log_info "Creating target directory for symlink: $target"
            mkdir -p "$target"
        # If it exists and is not a directory, error out
        elif [[ -e "$dir" && ! -d "$dir" ]]; then
            die "$dir exists but is not a directory. Please remove it."
        # Otherwise just create normally
        else
            mkdir -p "$dir"
        fi
    }

    # Create base config directory first to ensure parent exists
    safe_mkdir "$AGENT_CONFIG_DIR"
    safe_mkdir "$AGENT_SESSIONS_DIR"
    safe_mkdir "$AGENT_CONTEXTS_DIR"
    # Note: AGENT_TEMPLATES_DIR is in the dotfiles repo, not in ~/.config
    # So we don't create it here - it should already exist in the repo

    # Create default config if it doesn't exist
    if [[ ! -f "$AGENT_CONFIG_FILE" ]]; then
        cat > "$AGENT_CONFIG_FILE" <<EOF
# Agent Harness Configuration
default_template: feature
worktree_prefix: wt-
auto_sync: true
editor: \${EDITOR:-vim}
EOF
    fi
}

# Get the git root of current directory
get_git_root() {
    git rev-parse --show-toplevel 2>/dev/null
}

# Get repo name from path
get_repo_name() {
    basename "$(get_git_root)"
}

# Get session metadata file path
get_session_file() {
    local session_name="$1"
    local repo_name="${2:-$(get_repo_name)}"
    echo "$AGENT_SESSIONS_DIR/${repo_name}-${session_name}.yaml"
}

# Get context directory for session
get_context_dir() {
    local session_name="$1"
    local repo_name="${2:-$(get_repo_name)}"
    echo "$AGENT_CONTEXTS_DIR/${repo_name}/session-${session_name}"
}

# Get global context directory for repo
get_global_context_dir() {
    local repo_name="${1:-$(get_repo_name)}"
    echo "$AGENT_CONTEXTS_DIR/${repo_name}/global"
}

# Check if session exists
session_exists() {
    local session_name="$1"
    local session_file=$(get_session_file "$session_name")
    [[ -f "$session_file" ]]
}

# Get value from session yaml (simple grep-based parser)
get_session_value() {
    local session_name="$1"
    local key="$2"
    local session_file=$(get_session_file "$session_name")

    grep "^${key}:" "$session_file" | cut -d' ' -f2- | tr -d '"'
}

# ============================================================================
# Core Commands
# ============================================================================

# Create a new agent session with worktree
cmd_new() {
    local session_name=""
    local branch_name=""
    local template="$DEFAULT_TEMPLATE"
    local base_branch="main"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --branch=*)
                branch_name="${1#*=}"
                shift
                ;;
            --template=*)
                template="${1#*=}"
                shift
                ;;
            --base=*)
                base_branch="${1#*=}"
                shift
                ;;
            *)
                if [[ -z "$session_name" ]]; then
                    session_name="$1"
                else
                    die "Unknown argument: $1"
                fi
                shift
                ;;
        esac
    done

    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent new <session-name>"

    # Ensure we're in a git repo
    local git_root=$(get_git_root) || die "Not in a git repository"
    local repo_name=$(get_repo_name)

    # Check if session already exists
    if session_exists "$session_name"; then
        die "Session '$session_name' already exists. Use 'agent switch $session_name' or choose a different name."
    fi

    # Default branch name if not provided
    [[ -z "$branch_name" ]] && branch_name="agent/${session_name}"

    # Create worktree path
    local worktree_dir="${git_root}-${WORKTREE_PREFIX}${session_name}"

    log_step "Creating new agent session: $session_name"

    # Create git worktree
    log_info "Creating git worktree at: $worktree_dir"
    if git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
        # Branch exists, check it out
        git worktree add "$worktree_dir" "$branch_name"
    else
        # Create new branch
        git worktree add -b "$branch_name" "$worktree_dir" "$base_branch"
    fi

    # Create context directory
    local context_dir=$(get_context_dir "$session_name")
    mkdir -p "$context_dir/shared-tempfiles"

    # Create session metadata
    local session_file=$(get_session_file "$session_name")
    cat > "$session_file" <<EOF
name: $session_name
repo: $git_root
worktree: $worktree_dir
branch: $branch_name
created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
last_active: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
template: $template
context_dir: $context_dir
status: active
notes: ""
EOF

    # Apply template if it exists
    local template_file="$AGENT_TEMPLATES_DIR/${template}.yaml"
    if [[ -f "$template_file" ]]; then
        log_info "Applying template: $template"
        apply_template "$template_file" "$context_dir" "$session_name"
    else
        # Create default context files
        cat > "$context_dir/context.md" <<EOF
# Session: $session_name

## Branch
\`$branch_name\`

## Objective
[Describe what this session is working on]

## Approach
[Outline the approach]

## Progress
- [ ] Task 1

## Notes
[Any important notes]
EOF

        cat > "$context_dir/notes.md" <<EOF
# Development Notes - $session_name

## $(date +"%Y-%m-%d")
[Your notes here]
EOF
    fi

    # Create global context if it doesn't exist
    local global_dir=$(get_global_context_dir)
    if [[ ! -d "$global_dir" ]]; then
        mkdir -p "$global_dir"
        cat > "$global_dir/architecture.md" <<EOF
# Repository Architecture

[Document the high-level architecture of the codebase]
EOF

        cat > "$global_dir/conventions.md" <<EOF
# Code Conventions

[Document coding standards and conventions]
EOF
    fi

    log_success "Session '$session_name' created successfully!"
    echo ""
    echo -e "${BOLD}Session Details:${NC}"
    echo -e "  ${CYAN}Worktree:${NC} $worktree_dir"
    echo -e "  ${CYAN}Branch:${NC} $branch_name"
    echo -e "  ${CYAN}Context:${NC} $context_dir"
    echo ""
    echo -e "${BOLD}Next steps:${NC}"
    echo -e "  1. Switch to session: ${GREEN}agent switch $session_name${NC}"
    echo -e "  2. Edit context: ${GREEN}agent context $session_name --edit${NC}"
    echo -e "  3. Start coding! Launch your AI agent in: ${CYAN}$worktree_dir${NC}"
}

# Apply a template to context directory
apply_template() {
    local template_file="$1"
    local context_dir="$2"
    local session_name="$3"

    # Simple template engine: replace {{VAR}} with actual values
    # This is a basic implementation - could be enhanced with more sophisticated templating

    # For now, just copy template files if they exist
    # (Real implementation would parse YAML and generate files)
    log_warn "Template support is basic. Enhance as needed."
}

# List all active sessions
cmd_list() {
    init_agent_dirs

    if [[ ! "$(ls -A $AGENT_SESSIONS_DIR 2>/dev/null)" ]]; then
        log_info "No active sessions found."
        echo ""
        echo "Create a new session with: agent new <session-name>"
        return
    fi

    echo -e "${BOLD}Active Agent Sessions:${NC}"
    echo ""

    for session_file in "$AGENT_SESSIONS_DIR"/*.yaml; do
        [[ -e "$session_file" ]] || continue

        local name=$(grep "^name:" "$session_file" | cut -d' ' -f2-)
        local branch=$(grep "^branch:" "$session_file" | cut -d' ' -f2-)
        local status=$(grep "^status:" "$session_file" | cut -d' ' -f2-)
        local worktree=$(grep "^worktree:" "$session_file" | cut -d' ' -f2-)
        local notes=$(grep "^notes:" "$session_file" | cut -d' ' -f2- | tr -d '"')

        # Check if worktree still exists
        if [[ ! -d "$worktree" ]]; then
            status="${RED}missing${NC}"
        elif [[ "$status" == "active" ]]; then
            status="${GREEN}active${NC}"
        elif [[ "$status" == "paused" ]]; then
            status="${YELLOW}paused${NC}"
        fi

        echo -e "${BOLD}${CYAN}$name${NC}"
        echo -e "  Branch:   $branch"
        echo -e "  Status:   $status"
        echo -e "  Path:     $worktree"
        [[ -n "$notes" ]] && echo -e "  Notes:    $notes"
        echo ""
    done
}

# Switch to a session (cd into worktree)
cmd_switch() {
    local session_name="$1"
    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent switch <session-name>"

    session_exists "$session_name" || die "Session '$session_name' not found. Run 'agent list' to see available sessions."

    local worktree=$(get_session_value "$session_name" "worktree")

    if [[ ! -d "$worktree" ]]; then
        die "Worktree directory not found: $worktree. Session may be corrupted."
    fi

    # Update last_active timestamp
    local session_file=$(get_session_file "$session_name")
    local tmp_file=$(mktemp)
    sed "s/^last_active:.*/last_active: $(date -u +"%Y-%m-%dT%H:%M:%SZ")/" "$session_file" > "$tmp_file"
    mv "$tmp_file" "$session_file"

    # Export environment variable for prompt integration
    export AGENT_SESSION="$session_name"

    # Change to worktree directory
    cd "$worktree"

    log_success "Switched to session: $session_name"
    log_info "Working directory: $worktree"

    # If running in an interactive shell, start a new shell with the session active
    if [[ $- == *i* ]]; then
        echo ""
        echo -e "${BOLD}Entering session environment...${NC}"
        echo -e "Type ${GREEN}exit${NC} to leave this session."
        echo ""
        exec bash --init-file <(echo "
            source ~/.bashrc
            export AGENT_SESSION='$session_name'
            export PS1='${MAGENTA}[$session_name]${NC} \$PS1'
            cd $worktree
        ")
    fi
}

# View or edit session context
cmd_context() {
    local session_name="$1"
    local edit=false

    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --edit|-e)
                edit=true
                shift
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
    done

    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent context <session-name> [--edit]"

    session_exists "$session_name" || die "Session '$session_name' not found."

    local context_dir=$(get_context_dir "$session_name")
    local context_file="$context_dir/context.md"

    if [[ ! -f "$context_file" ]]; then
        die "Context file not found: $context_file"
    fi

    if $edit; then
        ${EDITOR:-vim} "$context_file"
    else
        ${PAGER:-less} "$context_file"
    fi
}

# Sync session with upstream changes
cmd_sync() {
    local session_name="$1"
    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent sync <session-name>"

    session_exists "$session_name" || die "Session '$session_name' not found."

    local worktree=$(get_session_value "$session_name" "worktree")
    local branch=$(get_session_value "$session_name" "branch")

    log_step "Syncing session: $session_name"

    cd "$worktree"

    log_info "Fetching latest changes..."
    git fetch origin

    log_info "Rebasing $branch onto origin/main..."
    git rebase origin/main || {
        log_error "Rebase failed. Please resolve conflicts manually."
        log_info "After resolving, run: git rebase --continue"
        exit 1
    }

    log_success "Session synced successfully!"
}

# Close a session (remove worktree and optionally delete branch)
cmd_close() {
    local session_name="$1"
    local delete_branch=false
    local archive=false

    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --delete-branch)
                delete_branch=true
                shift
                ;;
            --archive)
                archive=true
                shift
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
    done

    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent close <session-name>"

    session_exists "$session_name" || die "Session '$session_name' not found."

    local worktree=$(get_session_value "$session_name" "worktree")
    local branch=$(get_session_value "$session_name" "branch")
    local context_dir=$(get_context_dir "$session_name")
    local session_file=$(get_session_file "$session_name")

    log_step "Closing session: $session_name"

    # Archive context if requested
    if $archive; then
        local archive_dir="$AGENT_CONFIG_DIR/archive/$(get_repo_name)"
        mkdir -p "$archive_dir"
        local archive_file="$archive_dir/${session_name}-$(date +%Y%m%d-%H%M%S).tar.gz"

        log_info "Archiving context to: $archive_file"
        tar -czf "$archive_file" -C "$(dirname $context_dir)" "$(basename $context_dir)"
    fi

    # Remove worktree
    if [[ -d "$worktree" ]]; then
        log_info "Removing worktree: $worktree"
        git worktree remove "$worktree" --force
    fi

    # Delete branch if requested
    if $delete_branch; then
        log_info "Deleting branch: $branch"
        git branch -D "$branch" 2>/dev/null || true
    fi

    # Remove context directory
    log_info "Removing context directory"
    rm -rf "$context_dir"

    # Remove session file
    rm -f "$session_file"

    log_success "Session closed successfully!"
}

# Share context between sessions
cmd_share_context() {
    local from_session="$1"
    local to_session="$2"
    local file=""

    shift 2
    while [[ $# -gt 0 ]]; do
        case $1 in
            --file=*)
                file="${1#*=}"
                shift
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
    done

    [[ -z "$from_session" || -z "$to_session" || -z "$file" ]] && \
        die "Usage: agent share-context <from-session> <to-session> --file=<filename>"

    session_exists "$from_session" || die "Source session '$from_session' not found."
    session_exists "$to_session" || die "Target session '$to_session' not found."

    local from_context=$(get_context_dir "$from_session")
    local to_context=$(get_context_dir "$to_session")
    local from_file="$from_context/$file"
    local to_file="$to_context/$file"

    [[ ! -f "$from_file" ]] && die "File not found: $from_file"

    log_info "Copying $file from '$from_session' to '$to_session'"
    cp "$from_file" "$to_file"

    log_success "Context shared successfully!"
}

# Lock a session
cmd_lock() {
    local session_name="$1"
    local reason="${2:-No reason provided}"

    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent lock <session-name> <reason>"

    session_exists "$session_name" || die "Session '$session_name' not found."

    local context_dir=$(get_context_dir "$session_name")
    local lockfile="$context_dir/.lock"

    if [[ -f "$lockfile" ]]; then
        log_error "Session is already locked:"
        cat "$lockfile"
        exit 1
    fi

    echo "$USER@$(hostname) - $reason - $(date)" > "$lockfile"
    log_success "Session locked: $session_name"
}

# Unlock a session
cmd_unlock() {
    local session_name="$1"

    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent unlock <session-name>"

    session_exists "$session_name" || die "Session '$session_name' not found."

    local context_dir=$(get_context_dir "$session_name")
    local lockfile="$context_dir/.lock"

    if [[ ! -f "$lockfile" ]]; then
        log_warn "Session is not locked: $session_name"
        exit 0
    fi

    rm -f "$lockfile"
    log_success "Session unlocked: $session_name"
}

# Get current session
cmd_current() {
    if [[ -n "${AGENT_SESSION:-}" ]]; then
        echo "$AGENT_SESSION"
    else
        # Try to infer from current directory
        local git_root=$(get_git_root 2>/dev/null) || exit 1
        local current_dir=$(pwd)

        for session_file in "$AGENT_SESSIONS_DIR"/*.yaml; do
            [[ -e "$session_file" ]] || continue
            local worktree=$(grep "^worktree:" "$session_file" | cut -d' ' -f2-)
            if [[ "$current_dir" == "$worktree"* ]]; then
                grep "^name:" "$session_file" | cut -d' ' -f2-
                exit 0
            fi
        done

        exit 1
    fi
}

# Shepherd - Review and address PR comments
cmd_shepherd() {
    local pr_number=""
    local branch=""
    local dry_run=false
    local auto_apply=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --pr=*)
                pr_number="${1#*=}"
                shift
                ;;
            --branch=*)
                branch="${1#*=}"
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --auto-apply)
                auto_apply=true
                shift
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
    done

    # Ensure we have gh CLI
    if ! command -v gh &> /dev/null; then
        die "GitHub CLI (gh) is required but not installed. Install from: https://cli.github.com/"
    fi

    # Determine PR number
    if [[ -z "$pr_number" ]]; then
        if [[ -n "$branch" ]]; then
            # Get PR for specific branch
            log_info "Finding PR for branch: $branch"
            pr_number=$(gh pr list --head "$branch" --json number --jq '.[0].number' 2>/dev/null)
        else
            # Get PR for current branch
            local current_branch=$(git branch --show-current 2>/dev/null)
            if [[ -z "$current_branch" ]]; then
                die "Not on a branch. Use --pr=<number> or --branch=<name>"
            fi
            log_info "Finding PR for current branch: $current_branch"
            pr_number=$(gh pr list --head "$current_branch" --json number --jq '.[0].number' 2>/dev/null)
        fi

        if [[ -z "$pr_number" || "$pr_number" == "null" ]]; then
            die "No PR found for this branch. Use --pr=<number> to specify manually."
        fi
    fi

    log_step "Shepherding PR #$pr_number"
    echo ""

    # Get PR info
    local pr_info=$(gh pr view "$pr_number" --json title,body,reviews,reviewRequests,state 2>/dev/null)
    if [[ -z "$pr_info" ]]; then
        die "Failed to fetch PR #$pr_number. Check your permissions and network."
    fi

    local pr_title=$(echo "$pr_info" | jq -r '.title')
    local pr_state=$(echo "$pr_info" | jq -r '.state')

    echo -e "${BOLD}PR: #$pr_number${NC}"
    echo -e "${CYAN}$pr_title${NC}"
    echo -e "State: $pr_state"
    echo ""

    # Get review comments
    log_info "Fetching review comments..."
    local comments_json=$(gh api "repos/:owner/:repo/pulls/$pr_number/comments" 2>/dev/null)

    if [[ -z "$comments_json" || "$comments_json" == "[]" ]]; then
        log_success "No review comments found! ðŸŽ‰"
        return 0
    fi

    # Count comments
    local total_comments=$(echo "$comments_json" | jq 'length')
    log_info "Found $total_comments review comments"
    echo ""

    # Create temporary working directory for this shepherd session
    local shepherd_dir="/tmp/agent-shepherd-$$"
    mkdir -p "$shepherd_dir"

    # Save comments to file for processing
    echo "$comments_json" > "$shepherd_dir/comments.json"

    # Process each comment
    local comment_idx=0
    echo "$comments_json" | jq -c '.[]' | while read -r comment; do
        ((comment_idx++))

        local comment_id=$(echo "$comment" | jq -r '.id')
        local comment_body=$(echo "$comment" | jq -r '.body')
        local comment_path=$(echo "$comment" | jq -r '.path')
        local comment_line=$(echo "$comment" | jq -r '.line // .original_line')
        local comment_user=$(echo "$comment" | jq -r '.user.login')
        local created_at=$(echo "$comment" | jq -r '.created_at')
        local diff_hunk=$(echo "$comment" | jq -r '.diff_hunk')

        echo -e "${BOLD}${MAGENTA}Comment $comment_idx/$total_comments${NC}"
        echo -e "${BOLD}File:${NC} $comment_path:$comment_line"
        echo -e "${BOLD}Author:${NC} $comment_user ($(date -d "$created_at" "+%b %d, %Y" 2>/dev/null || echo "$created_at"))"
        echo -e "${BOLD}Comment:${NC}"
        echo "$comment_body" | sed 's/^/  /'
        echo ""
        echo -e "${BOLD}Context:${NC}"
        echo "$diff_hunk" | sed 's/^/  /'
        echo ""

        # Save comment details for analysis
        cat > "$shepherd_dir/comment-$comment_idx.json" <<EOF
{
  "id": $comment_id,
  "path": "$comment_path",
  "line": $comment_line,
  "user": "$comment_user",
  "body": $(echo "$comment" | jq -c '.body'),
  "diff_hunk": $(echo "$comment" | jq -c '.diff_hunk')
}
EOF

        if $dry_run; then
            echo -e "${YELLOW}[DRY RUN]${NC} Would analyze and suggest action for this comment"
            echo ""
            continue
        fi

        # Interactive prompt for action
        echo -e "${BOLD}What would you like to do?${NC}"
        echo "  1) Investigate & suggest fix"
        echo "  2) View full file context"
        echo "  3) Mark as resolved (reply)"
        echo "  4) Skip for now"
        echo "  q) Quit shepherd"
        echo ""

        if ! $auto_apply; then
            read -p "Choose action [1-4, q]: " action
        else
            action="1"
            echo "Auto-apply mode: choosing action 1 (investigate & suggest fix)"
        fi

        case "$action" in
            1)
                # Call helper script to analyze and suggest fix
                if [[ -x "$(dirname "${BASH_SOURCE[0]}")/agent-shepherd-analyze" ]]; then
                    "$(dirname "${BASH_SOURCE[0]}")/agent-shepherd-analyze" \
                        --comment="$shepherd_dir/comment-$comment_idx.json" \
                        --pr="$pr_number" \
                        ${auto_apply:+--auto-apply}
                else
                    log_warn "Helper script 'agent-shepherd-analyze' not found."
                    log_info "You can manually investigate: $comment_path:$comment_line"
                fi
                ;;
            2)
                # Show full file
                if [[ -f "$comment_path" ]]; then
                    ${PAGER:-less} "+${comment_line}g" "$comment_path"
                else
                    log_error "File not found: $comment_path"
                fi
                ;;
            3)
                # Reply to comment
                echo ""
                read -p "Enter reply message (or press Enter to skip): " reply_msg
                if [[ -n "$reply_msg" ]]; then
                    gh api "repos/:owner/:repo/pulls/$pr_number/comments/$comment_id/replies" \
                        -X POST \
                        -f body="$reply_msg" >/dev/null 2>&1 && \
                        log_success "Reply posted!" || \
                        log_error "Failed to post reply"
                fi
                ;;
            4)
                log_info "Skipping comment"
                ;;
            q|Q)
                log_info "Exiting shepherd"
                rm -rf "$shepherd_dir"
                exit 0
                ;;
            *)
                log_warn "Invalid choice, skipping"
                ;;
        esac

        echo ""
        echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
        echo ""
    done

    # Cleanup
    rm -rf "$shepherd_dir"

    echo ""
    log_success "Shepherd session complete!"
    log_info "Review the PR: gh pr view $pr_number --web"
}

# ============================================================================
# AI Tool Integration
# ============================================================================

# Get config value from YAML (simple parser)
get_config_value() {
    local key="$1"
    local default="${2:-}"

    if [[ ! -f "$AGENT_CONFIG_FILE" ]]; then
        echo "$default"
        return
    fi

    # Simple YAML parser: handles nested keys with dots (e.g., ai_tool.command)
    local value=$(grep "^${key//./ }: " "$AGENT_CONFIG_FILE" 2>/dev/null | sed 's/^[^:]*: *//' | tr -d '"')

    if [[ -z "$value" ]]; then
        echo "$default"
    else
        echo "$value"
    fi
}

# Set config value in YAML
set_config_value() {
    local key="$1"
    local value="$2"

    # Create config if doesn't exist
    [[ ! -f "$AGENT_CONFIG_FILE" ]] && init_agent_dirs

    # Check if key exists
    if grep -q "^${key}: " "$AGENT_CONFIG_FILE" 2>/dev/null; then
        # Update existing key
        local tmp_file=$(mktemp)
        sed "s|^${key}:.*|${key}: $value|" "$AGENT_CONFIG_FILE" > "$tmp_file"
        mv "$tmp_file" "$AGENT_CONFIG_FILE"
    else
        # Append new key
        echo "${key}: $value" >> "$AGENT_CONFIG_FILE"
    fi
}

# Configure AI tool interactively
cmd_config() {
    local show_only=false
    local reset=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --show)
                show_only=true
                shift
                ;;
            --reset)
                reset=true
                shift
                ;;
            *)
                die "Unknown argument: $1. Usage: agent config [--show|--reset]"
                ;;
        esac
    done

    # Show current config
    if $show_only; then
        echo -e "${BOLD}Current AI Tool Configuration:${NC}"
        echo ""
        echo -e "  ${CYAN}Command:${NC}        $(get_config_value 'ai_tool.command' 'not configured')"
        echo -e "  ${CYAN}Context Method:${NC} $(get_config_value 'ai_tool.context_method' 'not configured')"
        echo -e "  ${CYAN}Context Flag:${NC}   $(get_config_value 'ai_tool.context_flag' 'n/a')"
        echo -e "  ${CYAN}Context Env:${NC}    $(get_config_value 'ai_tool.context_env' 'n/a')"
        echo -e "  ${CYAN}Pass Directory:${NC} $(get_config_value 'ai_tool.pass_directory' 'true')"
        echo ""
        echo "Edit config: ${GREEN}agent config${NC}"
        echo "Reset config: ${GREEN}agent config --reset${NC}"
        return 0
    fi

    # Reset to defaults
    if $reset; then
        local tmp_file=$(mktemp)
        grep -v "^ai_tool\." "$AGENT_CONFIG_FILE" > "$tmp_file" 2>/dev/null || true
        mv "$tmp_file" "$AGENT_CONFIG_FILE"
        log_success "AI tool configuration reset"
        return 0
    fi

    # Interactive configuration
    log_step "AI Tool Configuration"
    echo ""
    echo "This will configure how 'agent launch' starts your AI coding assistant."
    echo ""

    # Get command
    echo -e "${BOLD}1. Command${NC}"
    echo "   What command launches your AI tool?"
    echo "   Examples: claude-code, cursor, aider, code"
    echo ""
    local current_cmd=$(get_config_value 'ai_tool.command' 'claude-code')
    read -p "   Command [$current_cmd]: " ai_command
    ai_command="${ai_command:-$current_cmd}"

    # Get context method
    echo ""
    echo -e "${BOLD}2. Context Method${NC}"
    echo "   How should context be passed to your tool?"
    echo "   ${CYAN}1)${NC} flag     - Pass via command line flag (e.g., --context context.md)"
    echo "   ${CYAN}2)${NC} env      - Pass via environment variable"
    echo "   ${CYAN}3)${NC} clipboard - Copy to clipboard (you paste manually)"
    echo "   ${CYAN}4)${NC} file     - Create .ai-context file in worktree"
    echo "   ${CYAN}5)${NC} manual   - Just show instructions"
    echo ""
    local current_method=$(get_config_value 'ai_tool.context_method' 'manual')
    read -p "   Method [1-5] ($current_method): " method_choice

    local context_method="$current_method"
    case "${method_choice:-$current_method}" in
        1|flag) context_method="flag" ;;
        2|env) context_method="env" ;;
        3|clipboard) context_method="clipboard" ;;
        4|file) context_method="file" ;;
        5|manual|*) context_method="manual" ;;
    esac

    # Get method-specific config
    local context_flag=""
    local context_env=""

    if [[ "$context_method" == "flag" ]]; then
        echo ""
        echo -e "${BOLD}3. Context Flag${NC}"
        echo "   What flag passes the context file?"
        echo "   Examples: --context, -c, --include"
        echo ""
        local current_flag=$(get_config_value 'ai_tool.context_flag' '--context')
        read -p "   Flag [$current_flag]: " context_flag
        context_flag="${context_flag:-$current_flag}"
    elif [[ "$context_method" == "env" ]]; then
        echo ""
        echo -e "${BOLD}3. Environment Variable${NC}"
        echo "   What environment variable should contain the context?"
        echo "   Examples: AGENT_CONTEXT, AI_CONTEXT"
        echo ""
        local current_env=$(get_config_value 'ai_tool.context_env' 'AGENT_CONTEXT')
        read -p "   Variable name [$current_env]: " context_env
        context_env="${context_env:-$current_env}"
    fi

    # Pass directory?
    echo ""
    echo -e "${BOLD}4. Working Directory${NC}"
    echo "   Should the worktree directory be passed as an argument?"
    echo "   (Usually 'yes' - the tool opens in the worktree)"
    echo ""
    local current_pass_dir=$(get_config_value 'ai_tool.pass_directory' 'true')
    read -p "   Pass directory? [y/N] (${current_pass_dir}): " pass_dir_input
    local pass_directory="${current_pass_dir}"
    case "${pass_dir_input:-${current_pass_dir:0:1}}" in
        y|Y|true|t) pass_directory="true" ;;
        *) pass_directory="false" ;;
    esac

    # Save configuration
    echo ""
    log_step "Saving configuration..."

    # Ensure ai_tool section exists in config
    if ! grep -q "^ai_tool:" "$AGENT_CONFIG_FILE" 2>/dev/null; then
        echo "" >> "$AGENT_CONFIG_FILE"
        echo "# AI Tool Configuration" >> "$AGENT_CONFIG_FILE"
        echo "ai_tool:" >> "$AGENT_CONFIG_FILE"
    fi

    # Save values
    set_config_value "  command" "$ai_command"
    set_config_value "  context_method" "$context_method"
    [[ -n "$context_flag" ]] && set_config_value "  context_flag" "$context_flag"
    [[ -n "$context_env" ]] && set_config_value "  context_env" "$context_env"
    set_config_value "  pass_directory" "$pass_directory"

    log_success "Configuration saved!"
    echo ""
    echo -e "${BOLD}Test your configuration:${NC}"
    echo -e "  ${GREEN}agent launch <session-name>${NC}"
}

# Launch AI tool with context
cmd_launch() {
    local session_name="$1"
    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent launch <session-name>"

    session_exists "$session_name" || die "Session '$session_name' not found."

    local worktree=$(get_session_value "$session_name" "worktree")
    local context_dir=$(get_context_dir "$session_name")
    local context_file="$context_dir/context.md"

    [[ ! -f "$context_file" ]] && die "Context file not found: $context_file"

    # Read AI tool configuration
    local ai_command=$(get_config_value 'ai_tool.command')
    local context_method=$(get_config_value 'ai_tool.context_method' 'manual')
    local context_flag=$(get_config_value 'ai_tool.context_flag' '--context')
    local context_env=$(get_config_value 'ai_tool.context_env' 'AGENT_CONTEXT')
    local pass_directory=$(get_config_value 'ai_tool.pass_directory' 'true')

    # Check if AI tool is configured
    if [[ -z "$ai_command" ]]; then
        log_warn "AI tool not configured yet!"
        echo ""
        echo "Run: ${GREEN}agent config${NC} to configure your AI tool"
        echo ""
        echo -e "${BOLD}Manual launch:${NC}"
        echo "  1. cd $worktree"
        echo "  2. Launch your AI tool"
        echo "  3. Share context: $context_file"
        return 1
    fi

    log_step "Launching AI tool: $ai_command"
    echo -e "  ${DIM}Session:${NC} $session_name"
    echo -e "  ${DIM}Worktree:${NC} $worktree"
    echo -e "  ${DIM}Context:${NC} $context_file"
    echo ""

    # Build command based on context method
    local launch_cmd="$ai_command"

    case "$context_method" in
        flag)
            launch_cmd="$ai_command $context_flag \"$context_file\""
            ;;
        env)
            export "$context_env=$context_file"
            log_info "Set $context_env=$context_file"
            ;;
        clipboard)
            if command -v pbcopy >/dev/null 2>&1; then
                cat "$context_file" | pbcopy
                log_info "Context copied to clipboard (pbcopy)"
            elif command -v xclip >/dev/null 2>&1; then
                cat "$context_file" | xclip -selection clipboard
                log_info "Context copied to clipboard (xclip)"
            elif command -v wl-copy >/dev/null 2>&1; then
                cat "$context_file" | wl-copy
                log_info "Context copied to clipboard (wl-copy)"
            else
                log_warn "No clipboard tool found. Context at: $context_file"
            fi
            ;;
        file)
            ln -sf "$context_file" "$worktree/.ai-context"
            log_info "Created symlink: $worktree/.ai-context -> context.md"
            ;;
        manual)
            log_info "Manual mode - no automatic context passing"
            echo ""
            echo -e "${BOLD}Context file:${NC} $context_file"
            echo "Share this with your AI tool after launching"
            echo ""
            ;;
    esac

    # Add directory argument if configured
    if [[ "$pass_directory" == "true" ]]; then
        launch_cmd="$launch_cmd \"$worktree\""
    fi

    # Change to worktree
    cd "$worktree" || die "Failed to cd to worktree: $worktree"

    # Launch the tool
    log_info "Executing: $launch_cmd"
    echo ""

    eval "$launch_cmd"
}

# Display help
cmd_help() {
    cat <<EOF
${BOLD}agent${NC} - Multi-Agent Session Manager

${BOLD}USAGE:${NC}
    agent <command> [arguments]

${BOLD}COMMANDS:${NC}
    ${CYAN}new${NC} <session-name> [options]
        Create a new agent session with git worktree
        Options:
            --branch=<name>      Git branch name (default: agent/<session-name>)
            --template=<name>    Session template (default: feature)
            --base=<branch>      Base branch (default: main)

    ${CYAN}list${NC}
        List all active agent sessions

    ${CYAN}switch${NC} <session-name>
        Switch to an agent session (cd into worktree)

    ${CYAN}context${NC} <session-name> [--edit]
        View or edit session context
        Options:
            --edit, -e    Open in editor instead of pager

    ${CYAN}sync${NC} <session-name>
        Sync session with upstream changes (fetch + rebase)

    ${CYAN}close${NC} <session-name> [options]
        Close a session and clean up
        Options:
            --delete-branch    Delete the git branch
            --archive          Archive context before closing

    ${CYAN}share-context${NC} <from-session> <to-session> --file=<filename>
        Share context file between sessions

    ${CYAN}lock${NC} <session-name> <reason>
        Lock a session to prevent concurrent edits

    ${CYAN}unlock${NC} <session-name>
        Unlock a session

    ${CYAN}current${NC}
        Show current active session

    ${CYAN}shepherd${NC} [options]
        Review and address PR comments interactively
        Options:
            --pr=<number>      PR number (auto-detected from branch if not provided)
            --branch=<name>    Branch name to find PR for
            --dry-run          Show comments without taking action
            --auto-apply       Automatically investigate and suggest fixes

    ${CYAN}config${NC} [--show|--reset]
        Configure AI tool integration for agent launch
        Options:
            --show             Show current configuration
            --reset            Reset to defaults
        (Run without options for interactive setup)

    ${CYAN}launch${NC} <session-name>
        Launch your configured AI tool with session context
        Automatically passes context based on your configuration

    ${CYAN}help${NC}
        Show this help message

${BOLD}EXAMPLES:${NC}
    # Create a new feature session
    agent new auth-feature --branch=feature/oauth

    # List all sessions
    agent list

    # Switch to a session
    agent switch auth-feature

    # View session context
    agent context auth-feature

    # Sync with main branch
    agent sync auth-feature

    # Close session when done
    agent close auth-feature --archive --delete-branch

    # Review PR comments and address them
    agent shepherd
    agent shepherd --pr=123
    agent shepherd --auto-apply

    # Configure and launch AI tools
    agent config                    # Interactive setup
    agent config --show             # View current config
    agent launch auth-feature       # Launch AI tool with context

${BOLD}CONFIGURATION:${NC}
    Config file: $AGENT_CONFIG_FILE
    Sessions: $AGENT_SESSIONS_DIR
    Contexts: $AGENT_CONTEXTS_DIR

${BOLD}MORE INFO:${NC}
    See docs/AGENT_WORKFLOWS.md for detailed workflows and examples
EOF
}

# ============================================================================
# Main
# ============================================================================

main() {
    # Initialize directories
    init_agent_dirs

    # Parse command
    local command="${1:-help}"
    shift || true

    case "$command" in
        new)
            cmd_new "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        switch|sw)
            cmd_switch "$@"
            ;;
        context|ctx)
            cmd_context "$@"
            ;;
        sync)
            cmd_sync "$@"
            ;;
        close|rm)
            cmd_close "$@"
            ;;
        share-context)
            cmd_share_context "$@"
            ;;
        lock)
            cmd_lock "$@"
            ;;
        unlock)
            cmd_unlock "$@"
            ;;
        current)
            cmd_current "$@"
            ;;
        shepherd|shep)
            cmd_shepherd "$@"
            ;;
        config|configure)
            cmd_config "$@"
            ;;
        launch|run|start)
            cmd_launch "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            log_error "Unknown command: $command"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
