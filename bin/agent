#!/usr/bin/env bash

# agent - Multi-Agent Session Manager
# Manages parallel AI coding sessions using git worktrees with shared context
#
# Usage:
#   agent new <session-name> [--branch=<branch>] [--template=<template>]
#   agent list
#   agent switch <session-name>
#   agent context <session-name> [--edit]
#   agent sync <session-name>
#   agent close <session-name> [--delete-branch] [--archive]
#   agent share-context <from-session> <to-session> --file=<filename>
#   agent lock <session-name> <reason>
#   agent unlock <session-name>
#   agent current
#   agent help

set -euo pipefail

# ============================================================================
# Configuration
# ============================================================================

AGENT_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/agents"
AGENT_SESSIONS_DIR="$AGENT_CONFIG_DIR/sessions"
AGENT_CONTEXTS_DIR="$AGENT_CONFIG_DIR/contexts"
# Templates are stored in the dotfiles repo, not in the config directory
DOTFILES_DIR="${DOTFILES_DIR:-$HOME/.dotfiles}"
AGENT_TEMPLATES_DIR="$DOTFILES_DIR/templates/agents"
AGENT_CONFIG_FILE="$AGENT_CONFIG_DIR/config.yaml"

# Default configuration (can be overridden in config.yaml)
DEFAULT_TEMPLATE="feature"
WORKTREE_PREFIX="wt-"
AUTO_SYNC=true

# Colors
RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
MAGENTA=$'\033[0;35m'
CYAN=$'\033[0;36m'
BOLD=$'\033[1m'
DIM=$'\033[2m'
NC=$'\033[0m' # No Color

# ============================================================================
# Utility Functions
# ============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_step() {
    echo -e "${CYAN}â–¶${NC} $1"
}

die() {
    log_error "$1"
    exit 1
}

# Initialize agent directories
init_agent_dirs() {
    # Check if ~/.config exists and is not a directory
    local config_parent="${XDG_CONFIG_HOME:-$HOME/.config}"
    if [[ -e "$config_parent" && ! -d "$config_parent" ]]; then
        die "$config_parent exists but is not a directory. Please remove it or use XDG_CONFIG_HOME to specify a different location."
    fi

    # Helper function to create directory, removing broken symlinks
    safe_mkdir() {
        local dir="$1"

        # If it's a broken symlink, remove it and create real directory
        if [[ -L "$dir" && ! -e "$dir" ]]; then
            log_warn "Removing broken symlink: $dir"
            rm -f "$dir"
        fi

        # If it exists and is not a directory, error out
        if [[ -e "$dir" && ! -d "$dir" ]]; then
            die "$dir exists but is not a directory. Please remove it."
        fi

        # Create directory
        mkdir -p "$dir"
    }

    # Create base config directory first to ensure parent exists
    safe_mkdir "$AGENT_CONFIG_DIR"
    safe_mkdir "$AGENT_SESSIONS_DIR"
    safe_mkdir "$AGENT_CONTEXTS_DIR"
    # Note: AGENT_TEMPLATES_DIR is in the dotfiles repo, not in ~/.config
    # So we don't create it here - it should already exist in the repo

    # Create default config if it doesn't exist
    if [[ ! -f "$AGENT_CONFIG_FILE" ]]; then
        cat > "$AGENT_CONFIG_FILE" <<EOF
# Agent Harness Configuration
default_template: feature
worktree_prefix: wt-
auto_sync: true
editor: \${EDITOR:-vim}
EOF
    fi
}

# Get the git root of current directory
get_git_root() {
    git rev-parse --show-toplevel 2>/dev/null
}

# Get repo name from path
get_repo_name() {
    basename "$(get_git_root)"
}

# Get session metadata file path
get_session_file() {
    local session_name="$1"
    local repo_name="${2:-$(get_repo_name)}"
    echo "$AGENT_SESSIONS_DIR/${repo_name}-${session_name}.yaml"
}

# Get context directory for session
get_context_dir() {
    local session_name="$1"
    local repo_name="${2:-$(get_repo_name)}"
    echo "$AGENT_CONTEXTS_DIR/${repo_name}/session-${session_name}"
}

# Get global context directory for repo
get_global_context_dir() {
    local repo_name="${1:-$(get_repo_name)}"
    echo "$AGENT_CONTEXTS_DIR/${repo_name}/global"
}

# Check if session exists
session_exists() {
    local session_name="$1"
    local session_file=$(get_session_file "$session_name")
    [[ -f "$session_file" ]]
}

# Get value from session yaml (simple grep-based parser)
get_session_value() {
    local session_name="$1"
    local key="$2"
    local session_file=$(get_session_file "$session_name")

    grep "^${key}:" "$session_file" | cut -d' ' -f2- | tr -d '"'
}

# ============================================================================
# Core Commands
# ============================================================================

# Create a new agent session with worktree
cmd_new() {
    local session_name=""
    local branch_name=""
    local template="$DEFAULT_TEMPLATE"
    local base_branch=""  # Will be set to current branch if not specified

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --branch=*)
                branch_name="${1#*=}"
                shift
                ;;
            --template=*)
                template="${1#*=}"
                shift
                ;;
            --base=*)
                base_branch="${1#*=}"
                shift
                ;;
            *)
                if [[ -z "$session_name" ]]; then
                    session_name="$1"
                else
                    die "Unknown argument: $1"
                fi
                shift
                ;;
        esac
    done

    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent new <session-name>"

    # Ensure we're in a git repo
    local git_root=$(get_git_root) || die "Not in a git repository"
    local repo_name=$(get_repo_name)

    # Default base branch to current branch if not specified
    if [[ -z "$base_branch" ]]; then
        base_branch=$(git rev-parse --abbrev-ref HEAD)
        log_info "Using current branch as base: $base_branch"
    fi

    # Check if session already exists
    if session_exists "$session_name"; then
        die "Session '$session_name' already exists. Use 'agent switch $session_name' or choose a different name."
    fi

    # Default branch name if not provided
    [[ -z "$branch_name" ]] && branch_name="agent/${session_name}"

    # Create worktree path
    local worktree_dir="${git_root}-${WORKTREE_PREFIX}${session_name}"

    log_step "Creating new agent session: $session_name"

    # Create git worktree
    log_info "Creating git worktree at: $worktree_dir"
    if git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
        # Branch exists, check it out
        git worktree add "$worktree_dir" "$branch_name"
    else
        # Create new branch
        git worktree add -b "$branch_name" "$worktree_dir" "$base_branch"
    fi

    # Create context directory
    local context_dir=$(get_context_dir "$session_name")
    mkdir -p "$context_dir/shared-tempfiles"

    # Create session metadata
    local session_file=$(get_session_file "$session_name")
    cat > "$session_file" <<EOF
name: $session_name
repo: $git_root
worktree: $worktree_dir
branch: $branch_name
base_branch: $base_branch
created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
last_active: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
template: $template
context_dir: $context_dir
status: active
notes: ""
EOF

    # Apply template if it exists
    local template_file="$AGENT_TEMPLATES_DIR/${template}.yaml"
    if [[ -f "$template_file" ]]; then
        log_info "Applying template: $template"
        apply_template "$template_file" "$context_dir" "$session_name" "$branch_name" "$base_branch"
    else
        # Create default context files
        cat > "$context_dir/context.md" <<EOF
# Session: $session_name

## Branch
\`$branch_name\`

## Objective
[Describe what this session is working on]

## Approach
[Outline the approach]

## Progress
- [ ] Task 1

## Notes
[Any important notes]
EOF

        cat > "$context_dir/notes.md" <<EOF
# Development Notes - $session_name

## $(date +"%Y-%m-%d")
[Your notes here]
EOF
    fi

    # Create global context if it doesn't exist
    local global_dir=$(get_global_context_dir)
    if [[ ! -d "$global_dir" ]]; then
        mkdir -p "$global_dir"
        cat > "$global_dir/architecture.md" <<EOF
# Repository Architecture

[Document the high-level architecture of the codebase]
EOF

        cat > "$global_dir/conventions.md" <<EOF
# Code Conventions

[Document coding standards and conventions]
EOF
    fi

    log_success "Session '$session_name' created successfully!"
    echo ""
    echo -e "${BOLD}Session Details:${NC}"
    echo -e "  ${CYAN}Worktree:${NC} $worktree_dir"
    echo -e "  ${CYAN}Branch:${NC} $branch_name"
    echo -e "  ${CYAN}Context:${NC} $context_dir"
    echo ""
    echo -e "${BOLD}Next steps:${NC}"
    echo -e "  1. Switch to session: ${GREEN}agent switch $session_name${NC}"
    echo -e "  2. Edit context: ${GREEN}agent context $session_name --edit${NC}"
    echo -e "  3. Start coding! Launch your AI agent in: ${CYAN}$worktree_dir${NC}"
}

# Apply a template to context directory
apply_template() {
    local template_file="$1"
    local context_dir="$2"
    local session_name="$3"
    local branch_name="$4"
    local base_branch="$5"

    # Variable substitution map
    local date_now=$(date +"%Y-%m-%d")
    local feature_name=$(echo "$session_name" | sed 's/-/ /g' | sed 's/\b\(.\)/\u\1/g')

    # Check if yq is available for YAML parsing
    if command -v yq &>/dev/null; then
        log_info "Using yq for template parsing"

        # Extract file list from template
        local files=$(yq eval '.files | keys | .[]' "$template_file" 2>/dev/null)

        if [[ -z "$files" ]]; then
            log_warn "Template has no files section, using fallback"
            apply_template_fallback "$context_dir" "$session_name" "$branch_name" "$base_branch"
            return
        fi

        # Process each file in the template
        while IFS= read -r file_path; do
            local target_file="$context_dir/$file_path"
            local file_content=$(yq eval ".files.\"$file_path\"" "$template_file")

            # Create parent directory if needed
            mkdir -p "$(dirname "$target_file")"

            # Perform variable substitutions
            # Use | as delimiter instead of / to handle branch names with slashes
            echo "$file_content" | \
                sed "s|{{SESSION_NAME}}|$session_name|g" | \
                sed "s|{{FEATURE_NAME}}|$feature_name|g" | \
                sed "s|{{BRANCH}}|$branch_name|g" | \
                sed "s|{{BASE_BRANCH}}|$base_branch|g" | \
                sed "s|{{DATE}}|$date_now|g" \
                > "$target_file"

            log_info "Created: $file_path"
        done <<< "$files"
    else
        log_warn "yq not found, using fallback template parsing"
        apply_template_fallback "$context_dir" "$session_name" "$branch_name" "$base_branch"
    fi
}

# Fallback template application when yq is not available
apply_template_fallback() {
    local context_dir="$1"
    local session_name="$2"
    local branch_name="$3"
    local base_branch="$4"
    local date_now=$(date +"%Y-%m-%d")

    # Create standard context.md
    cat > "$context_dir/context.md" <<EOF
# Session: $session_name

## Branch
\`$branch_name\` (based on \`$base_branch\`)

## Objective
[Describe what this session is working on]

## Requirements
- [ ] Requirement 1
- [ ] Requirement 2

## Approach
1. Design the solution
2. Implement core functionality
3. Add tests
4. Document changes

## Progress
- [ ] Design complete
- [ ] Implementation in progress
- [ ] Tests written
- [ ] Documentation updated

## Notes
[Add implementation notes here]

## Dependencies
[List any dependencies or blockers]
EOF

    # Create notes.md
    cat > "$context_dir/notes.md" <<EOF
# Development Notes

## $date_now
[Your notes here]
EOF

    # Create .gitkeep for shared-tempfiles
    touch "$context_dir/shared-tempfiles/.gitkeep"

    log_info "Created context files using fallback template"
}

# Heal missing context files for a session
# Call this from commands that need context to exist
ensure_session_context() {
    local session_name="$1"

    if ! session_exists "$session_name"; then
        die "Session '$session_name' not found"
    fi

    local context_dir=$(get_context_dir "$session_name")
    local context_file="$context_dir/context.md"

    # Check if context.md exists
    if [[ -f "$context_file" ]]; then
        return 0  # Context exists, nothing to do
    fi

    log_warn "Session context missing. Creating default context..."

    # Get session metadata
    local branch=$(get_session_value "$session_name" "branch")
    local base_branch=$(get_session_value "$session_name" "base_branch")

    # Create context directory if missing
    mkdir -p "$context_dir/shared-tempfiles"

    # Use fallback template to create context
    apply_template_fallback "$context_dir" "$session_name" "$branch" "$base_branch"

    log_info "Context healed for session: $session_name"
}

# List all active sessions
cmd_list() {
    init_agent_dirs

    if [[ ! "$(ls -A $AGENT_SESSIONS_DIR 2>/dev/null)" ]]; then
        log_info "No active sessions found."
        echo ""
        echo "Create a new session with: agent new <session-name>"
        return
    fi

    echo -e "${BOLD}Active Agent Sessions:${NC}"
    echo ""

    for session_file in "$AGENT_SESSIONS_DIR"/*.yaml; do
        [[ -e "$session_file" ]] || continue

        local name=$(grep "^name:" "$session_file" | cut -d' ' -f2-)
        local branch=$(grep "^branch:" "$session_file" | cut -d' ' -f2-)
        local status=$(grep "^status:" "$session_file" | cut -d' ' -f2-)
        local worktree=$(grep "^worktree:" "$session_file" | cut -d' ' -f2-)
        local notes=$(grep "^notes:" "$session_file" | cut -d' ' -f2- | tr -d '"')

        # Check if worktree still exists
        if [[ ! -d "$worktree" ]]; then
            status="${RED}missing${NC}"
        elif [[ "$status" == "active" ]]; then
            status="${GREEN}active${NC}"
        elif [[ "$status" == "paused" ]]; then
            status="${YELLOW}paused${NC}"
        fi

        echo -e "${BOLD}${CYAN}$name${NC}"
        echo -e "  Branch:   $branch"
        echo -e "  Status:   $status"
        echo -e "  Path:     $worktree"
        [[ -n "$notes" ]] && echo -e "  Notes:    $notes"
        echo ""
    done
}

# Switch to a session (cd into worktree)
cmd_switch() {
    local session_name="$1"
    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent switch <session-name>"

    session_exists "$session_name" || die "Session '$session_name' not found. Run 'agent list' to see available sessions."

    local worktree=$(get_session_value "$session_name" "worktree")

    if [[ ! -d "$worktree" ]]; then
        die "Worktree directory not found: $worktree. Session may be corrupted."
    fi

    # Ensure context files exist
    ensure_session_context "$session_name"

    # Update last_active timestamp
    local session_file=$(get_session_file "$session_name")
    local tmp_file=$(mktemp)
    sed "s/^last_active:.*/last_active: $(date -u +"%Y-%m-%dT%H:%M:%SZ")/" "$session_file" > "$tmp_file"
    mv "$tmp_file" "$session_file"

    # Export environment variable for prompt integration
    export AGENT_SESSION="$session_name"

    # Change to worktree directory
    cd "$worktree"

    log_success "Switched to session: $session_name"
    log_info "Working directory: $worktree"

    # If running in an interactive shell, start a new shell with the session active
    if [[ $- == *i* ]]; then
        echo ""
        echo -e "${BOLD}Entering session environment...${NC}"
        echo -e "Type ${GREEN}exit${NC} to leave this session."
        echo ""
        exec bash --init-file <(echo "
            source ~/.bashrc
            export AGENT_SESSION='$session_name'
            export PS1='${MAGENTA}[$session_name]${NC} \$PS1'
            cd $worktree
        ")
    fi
}

# View or edit session context
cmd_context() {
    local session_name="$1"
    local edit=false

    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --edit|-e)
                edit=true
                shift
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
    done

    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent context <session-name> [--edit]"

    session_exists "$session_name" || die "Session '$session_name' not found."

    # Ensure context files exist
    ensure_session_context "$session_name"

    local context_dir=$(get_context_dir "$session_name")
    local context_file="$context_dir/context.md"

    if $edit; then
        ${EDITOR:-vim} "$context_file"
    else
        ${PAGER:-less} "$context_file"
    fi
}

# Sync session with upstream changes
cmd_sync() {
    local session_name="$1"
    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent sync <session-name>"

    session_exists "$session_name" || die "Session '$session_name' not found."

    local worktree=$(get_session_value "$session_name" "worktree")
    local branch=$(get_session_value "$session_name" "branch")

    log_step "Syncing session: $session_name"

    cd "$worktree"

    log_info "Fetching latest changes..."
    git fetch origin

    log_info "Rebasing $branch onto origin/main..."
    git rebase origin/main || {
        log_error "Rebase failed. Please resolve conflicts manually."
        log_info "After resolving, run: git rebase --continue"
        exit 1
    }

    log_success "Session synced successfully!"
}

# Integrate session changes back to base branch (local merge, no PR)
cmd_integrate() {
    local session_name=""
    local push_after=false
    local close_after=false
    local no_ff=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --push)
                push_after=true
                shift
                ;;
            --close)
                close_after=true
                shift
                ;;
            --no-ff)
                no_ff=true
                shift
                ;;
            *)
                if [[ -z "$session_name" ]]; then
                    session_name="$1"
                else
                    die "Unknown argument: $1"
                fi
                shift
                ;;
        esac
    done

    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent integrate <session-name> [--push] [--close] [--no-ff]"
    session_exists "$session_name" || die "Session '$session_name' not found."

    local worktree=$(get_session_value "$session_name" "worktree")
    local branch=$(get_session_value "$session_name" "branch")
    local base_branch=$(get_session_value "$session_name" "base_branch")
    local git_root=$(get_session_value "$session_name" "repo")

    [[ -z "$base_branch" ]] && die "No base_branch found in session metadata. This session may have been created with an older version of the agent script."

    log_step "Integrating session '$session_name' into base branch '$base_branch'"

    # Save current directory
    local original_dir=$(pwd)

    # Go to main repo to merge
    cd "$git_root"

    # Check if we're currently on the base branch
    local current_branch=$(git rev-parse --abbrev-ref HEAD)

    if [[ "$current_branch" != "$base_branch" ]]; then
        log_info "Switching to base branch: $base_branch"
        git checkout "$base_branch" || die "Failed to checkout base branch '$base_branch'"
    fi

    # Merge the agent branch
    log_info "Merging $branch into $base_branch..."

    local merge_opts=()
    if $no_ff; then
        merge_opts+=(--no-ff)
    fi

    if git merge "${merge_opts[@]}" "$branch"; then
        log_success "Successfully merged $branch into $base_branch"

        # Push if requested
        if $push_after; then
            log_info "Pushing $base_branch to origin..."
            if git push origin "$base_branch"; then
                log_success "Pushed $base_branch to origin"
            else
                log_error "Failed to push. You can push manually later with: git push origin $base_branch"
            fi
        fi

        # Close session if requested
        if $close_after; then
            log_info "Closing session..."
            cd "$original_dir"
            cmd_close "$session_name" --delete-branch
        else
            log_info "Session '$session_name' is still active. Close it with: agent close $session_name"
            cd "$original_dir"
        fi
    else
        log_error "Merge failed. Please resolve conflicts manually."
        log_info "After resolving conflicts, run:"
        log_info "  git add ."
        log_info "  git commit"
        if $push_after; then
            log_info "  git push origin $base_branch"
        fi
        if $close_after; then
            log_info "  agent close $session_name"
        fi
        cd "$original_dir"
        exit 1
    fi
}

# Close a session (remove worktree and optionally delete branch)
cmd_close() {
    local session_name="$1"
    local delete_branch=false
    local archive=false

    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --delete-branch)
                delete_branch=true
                shift
                ;;
            --archive)
                archive=true
                shift
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
    done

    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent close <session-name>"

    session_exists "$session_name" || die "Session '$session_name' not found."

    local worktree=$(get_session_value "$session_name" "worktree")
    local branch=$(get_session_value "$session_name" "branch")
    local context_dir=$(get_context_dir "$session_name")
    local session_file=$(get_session_file "$session_name")

    log_step "Closing session: $session_name"

    # Archive context if requested
    if $archive; then
        local archive_dir="$AGENT_CONFIG_DIR/archive/$(get_repo_name)"
        mkdir -p "$archive_dir"
        local archive_file="$archive_dir/${session_name}-$(date +%Y%m%d-%H%M%S).tar.gz"

        log_info "Archiving context to: $archive_file"
        tar -czf "$archive_file" -C "$(dirname $context_dir)" "$(basename $context_dir)"
    fi

    # Remove worktree
    if [[ -d "$worktree" ]]; then
        log_info "Removing worktree: $worktree"
        git worktree remove "$worktree" --force
    fi

    # Delete branch if requested
    if $delete_branch; then
        log_info "Deleting branch: $branch"
        git branch -D "$branch" 2>/dev/null || true
    fi

    # Remove context directory
    log_info "Removing context directory"
    rm -rf "$context_dir"

    # Remove session file
    rm -f "$session_file"

    log_success "Session closed successfully!"
}

# Share context between sessions
cmd_share_context() {
    local from_session="$1"
    local to_session="$2"
    local file=""

    shift 2
    while [[ $# -gt 0 ]]; do
        case $1 in
            --file=*)
                file="${1#*=}"
                shift
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
    done

    [[ -z "$from_session" || -z "$to_session" || -z "$file" ]] && \
        die "Usage: agent share-context <from-session> <to-session> --file=<filename>"

    session_exists "$from_session" || die "Source session '$from_session' not found."
    session_exists "$to_session" || die "Target session '$to_session' not found."

    local from_context=$(get_context_dir "$from_session")
    local to_context=$(get_context_dir "$to_session")
    local from_file="$from_context/$file"
    local to_file="$to_context/$file"

    [[ ! -f "$from_file" ]] && die "File not found: $from_file"

    log_info "Copying $file from '$from_session' to '$to_session'"
    cp "$from_file" "$to_file"

    log_success "Context shared successfully!"
}

# Lock a session
cmd_lock() {
    local session_name="$1"
    local reason="${2:-No reason provided}"

    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent lock <session-name> <reason>"

    session_exists "$session_name" || die "Session '$session_name' not found."

    local context_dir=$(get_context_dir "$session_name")
    local lockfile="$context_dir/.lock"

    if [[ -f "$lockfile" ]]; then
        log_error "Session is already locked:"
        cat "$lockfile"
        exit 1
    fi

    echo "$USER@$(hostname) - $reason - $(date)" > "$lockfile"
    log_success "Session locked: $session_name"
}

# Unlock a session
cmd_unlock() {
    local session_name="$1"

    [[ -z "$session_name" ]] && die "Session name is required. Usage: agent unlock <session-name>"

    session_exists "$session_name" || die "Session '$session_name' not found."

    local context_dir=$(get_context_dir "$session_name")
    local lockfile="$context_dir/.lock"

    if [[ ! -f "$lockfile" ]]; then
        log_warn "Session is not locked: $session_name"
        exit 0
    fi

    rm -f "$lockfile"
    log_success "Session unlocked: $session_name"
}

# Get current session
cmd_current() {
    if [[ -n "${AGENT_SESSION:-}" ]]; then
        echo "$AGENT_SESSION"
    else
        # Try to infer from current directory
        local git_root=$(get_git_root 2>/dev/null) || exit 1
        local current_dir=$(pwd)

        for session_file in "$AGENT_SESSIONS_DIR"/*.yaml; do
            [[ -e "$session_file" ]] || continue
            local worktree=$(grep "^worktree:" "$session_file" | cut -d' ' -f2-)
            if [[ "$current_dir" == "$worktree"* ]]; then
                grep "^name:" "$session_file" | cut -d' ' -f2-
                exit 0
            fi
        done

        exit 1
    fi
}

# Shepherd - Review and address PR comments
cmd_shepherd() {
    local pr_number=""
    local branch=""
    local dry_run=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --pr=*)
                pr_number="${1#*=}"
                shift
                ;;
            --branch=*)
                branch="${1#*=}"
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            *)
                die "Unknown argument: $1"
                ;;
        esac
    done

    # Ensure we have gh CLI
    if ! command -v gh &> /dev/null; then
        die "GitHub CLI (gh) is required but not installed. Install from: https://cli.github.com/"
    fi

    # Determine PR number
    if [[ -z "$pr_number" ]]; then
        if [[ -n "$branch" ]]; then
            log_info "Finding PR for branch: $branch"
            pr_number=$(gh pr list --head "$branch" --json number --jq '.[0].number' 2>/dev/null)
        else
            local current_branch=$(git branch --show-current 2>/dev/null)
            if [[ -z "$current_branch" ]]; then
                die "Not on a branch. Use --pr=<number> or --branch=<name>"
            fi

            # If current branch is an agent branch, look for PR on base_branch instead
            local search_branch="$current_branch"
            if [[ "$current_branch" == agent/* ]]; then
                # Try to find the agent session and get its base_branch
                local git_root=$(get_git_root 2>/dev/null) || true
                local current_dir=$(pwd)

                for session_file in "$AGENT_SESSIONS_DIR"/*.yaml; do
                    [[ -e "$session_file" ]] || continue
                    local session_branch=$(grep "^branch:" "$session_file" | cut -d' ' -f2-)
                    if [[ "$session_branch" == "$current_branch" ]]; then
                        local base_branch=$(grep "^base_branch:" "$session_file" | cut -d' ' -f2-)
                        if [[ -n "$base_branch" ]]; then
                            search_branch="$base_branch"
                            log_info "Agent branch detected. Looking for PR on base branch: $base_branch"
                            break
                        fi
                    fi
                done
            else
                log_info "Finding PR for current branch: $current_branch"
            fi

            pr_number=$(gh pr list --head "$search_branch" --json number --jq '.[0].number' 2>/dev/null)
        fi

        if [[ -z "$pr_number" || "$pr_number" == "null" ]]; then
            die "No PR found for this branch. Use --pr=<number> to specify manually."
        fi
    fi

    log_step "Shepherding PR #$pr_number"
    echo ""

    # Get PR info
    local pr_info=$(gh pr view "$pr_number" --json title,url,state 2>/dev/null)
    if [[ -z "$pr_info" ]]; then
        die "Failed to fetch PR #$pr_number. Check your permissions and network."
    fi

    local pr_title=$(echo "$pr_info" | jq -r '.title')
    local pr_url=$(echo "$pr_info" | jq -r '.url')
    local pr_state=$(echo "$pr_info" | jq -r '.state')

    echo -e "${BOLD}PR: #$pr_number${NC}"
    echo -e "${CYAN}$pr_title${NC}"
    echo -e "State: $pr_state"
    echo -e "URL: $pr_url"
    echo ""

    # Fetch unresolved review threads with all comments
    log_info "Fetching unresolved review comments..."

    local threads_json=$(gh api graphql -f query='
      query($pr: Int!) {
        repository(owner: "august-innovations", name: "august") {
          pullRequest(number: $pr) {
            reviewThreads(first: 100) {
              nodes {
                isResolved
                comments(first: 20) {
                  nodes {
                    id
                    body
                    path
                    line
                    originalLine
                    diffHunk
                    author {
                      login
                    }
                    createdAt
                  }
                }
              }
            }
          }
        }
      }
    ' -F pr="$pr_number" 2>/dev/null)

    if [[ -z "$threads_json" || "$threads_json" == "null" ]]; then
        die "Failed to fetch review threads. Check your permissions and network."
    fi

    # Extract unresolved threads (with all comments in each thread)
    local unresolved_threads=$(echo "$threads_json" | jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)]')
    local thread_count=$(echo "$unresolved_threads" | jq 'length')

    if [[ "$thread_count" == "0" ]]; then
        log_success "No unresolved review comments found! ðŸŽ‰"
        return 0
    fi

    log_info "Found $thread_count unresolved review threads"
    echo ""

    # Determine if we're in an agent session
    local session_name=""
    local shepherd_file=""
    local worktree=$(pwd)

    if [[ -n "${AGENT_SESSION:-}" ]]; then
        session_name="$AGENT_SESSION"
    else
        # Try to infer from current directory
        local git_root=$(get_git_root 2>/dev/null) || true
        local current_dir=$(pwd)

        for session_file in "$AGENT_SESSIONS_DIR"/*.yaml; do
            [[ -e "$session_file" ]] || continue
            local wt=$(grep "^worktree:" "$session_file" | cut -d' ' -f2-)
            if [[ "$current_dir" == "$wt"* ]]; then
                session_name=$(grep "^name:" "$session_file" | cut -d' ' -f2-)
                worktree="$wt"
                break
            fi
        done
    fi

    # Get shepherd file location
    if [[ -n "$session_name" ]]; then
        # Ensure session context exists first
        ensure_session_context "$session_name"

        # Create shepherd.md in session context dir (separate from context.md)
        shepherd_file="$(get_context_dir "$session_name")/shepherd.md"
        log_info "Using session: $session_name"

        # Store PR number in session metadata
        local session_file=$(get_session_file "$session_name")
        local tmp_file=$(mktemp)
        if grep -q "^pr_number:" "$session_file"; then
            sed "s/^pr_number:.*/pr_number: $pr_number/" "$session_file" > "$tmp_file"
        else
            sed "/^status:/a\\
pr_number: $pr_number" "$session_file" > "$tmp_file"
        fi
        mv "$tmp_file" "$session_file"
    else
        # Not in a session, create temp context in global context dir
        local repo_name=$(get_repo_name)
        shepherd_file="$AGENT_CONTEXTS_DIR/${repo_name}/shepherd-pr-${pr_number}.md"
        mkdir -p "$(dirname "$shepherd_file")"
        log_info "Not in a session. Creating shepherd context in global dir."
    fi

    # Create/overwrite shepherd file with PR review comments
    cat > "$shepherd_file" <<EOF
# PR Review Comments - PR #$pr_number

**Title:** $pr_title
**URL:** $pr_url
**State:** $pr_state

## Task

Please address the following unresolved review comments on this PR. For each comment:
1. Review the comment and the code context
2. Make the necessary changes to address the feedback
3. Ensure the changes are correct and don't introduce new issues

---

EOF

    # Format each thread with all its comments using jq
    # This avoids bash loop subshell issues
    local threads_content=$(echo "$unresolved_threads" | jq -r '
      to_entries | map(
        "## Thread \(.key + 1): `\(.value.comments.nodes[0].path):\(.value.comments.nodes[0].line // .value.comments.nodes[0].originalLine)`\n\n" +
        "### Code Context\n\n```diff\n\(.value.comments.nodes[0].diffHunk)\n```\n\n" +
        "### Discussion\n\n" +
        (.value.comments.nodes | to_entries | map(
          if .key == 0 then
            "**Original Comment** by @\(.value.author.login) (\(.value.createdAt)):\n\n\(.value.body)\n"
          else
            "\n**Reply** by @\(.value.author.login) (\(.value.createdAt)):\n\n\(.value.body)\n"
          end
        ) | join("\n")) +
        "\n\n---\n"
      ) | join("\n")
    ')

    echo "$threads_content" >> "$shepherd_file"

    log_success "Shepherd context written: $shepherd_file"
    echo ""

    # If dry-run, just show the comments and exit
    if $dry_run; then
        echo -e "${BOLD}${CYAN}Preview of PR Comments:${NC}"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        cat "$shepherd_file"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo ""
        echo -e "${BOLD}Shepherd context saved to:${NC} $shepherd_file"
        echo ""
        echo "To address these comments, run: ${GREEN}agent shepherd --pr=$pr_number${NC}"
        return 0
    fi

    # Get AI command from config
    local ai_command=$(get_config_value 'ai_tool.command' 'claude-code')

    # Check if AI tool is configured
    if ! command -v "$ai_command" &> /dev/null; then
        log_warn "AI command '$ai_command' not found."
        echo ""
        echo -e "${BOLD}Shepherd file:${NC} $shepherd_file"
        echo -e "${BOLD}Install your AI tool or update config:${NC} agent config"
        echo ""
        log_info "Preview of PR comments:"
        cat "$shepherd_file"
        return 1
    fi

    log_step "Launching: $ai_command"
    echo -e "  ${DIM}PR:${NC} #$pr_number"
    echo -e "  ${DIM}Worktree:${NC} $worktree"
    echo -e "  ${DIM}Shepherd:${NC} $shepherd_file"
    echo ""
    echo -e "${BOLD}${GREEN}â†’ Run this command in your agent:${NC} ${CYAN}/agent-instructions${NC}"
    echo ""

    # Change to worktree and launch
    cd "$worktree" || die "Failed to cd to worktree: $worktree"
    exec "$ai_command" "$worktree"
}

# ============================================================================
# AI Tool Integration
# ============================================================================

# Setup global slash commands for AI tools
setup_ai_tool_integration() {
    local ai_command=$(get_config_value 'ai_tool.command' 'claude-code')

    # Setup Claude Code global slash command (handles both "claude" and "claude-code")
    if [[ "$ai_command" == "claude-code" ]] || [[ "$ai_command" == "claude" ]] || command -v claude-code &>/dev/null || command -v claude &>/dev/null; then
        local claude_commands_dir="${HOME}/.claude/commands"
        mkdir -p "$claude_commands_dir"

        cat > "$claude_commands_dir/agent-instructions.md" <<'EOF'
---
description: Read agent session context and instructions
---

# Agent Instructions

Read the session context for your current working directory.

First, check your current working directory and find the corresponding context file at:
`~/.config/agents/contexts/<repo-name>/<session-name>/context.md`

For agent worktrees (paths containing `wt-`), the context file contains:
- Your current objectives for this session
- Implementation approach
- Progress tracking
- Any PR review comments or other instructions

After reading the context file, proceed with the tasks outlined.
EOF
        log_info "Created Claude Code global slash command: ~/.claude/commands/agent-instructions.md"
    fi

    # Setup Codex global slash command
    if [[ "$ai_command" == "codex" ]] || command -v codex &>/dev/null; then
        local codex_prompts_dir="${HOME}/.codex/prompts"
        mkdir -p "$codex_prompts_dir"

        cat > "$codex_prompts_dir/agent-instructions.md" <<'EOF'
---
description: Read agent session context and instructions
---

# Agent Instructions

Read the session context for your current working directory.

The context file is located at:
`~/.config/agents/contexts/<repo-name>/<session-name>/context.md`

To find your session:
1. Check if you're in an agent worktree (path contains `wt-`)
2. The session context contains your objectives, approach, progress, and any PR review comments
3. Read the context file and proceed with the tasks outlined

First, let me help you find the right context file. What's your current working directory?
EOF
        log_info "Created Codex global slash command: ~/.codex/prompts/agent-instructions.md"
    fi
}

# Get config value from YAML (simple parser)
get_config_value() {
    local key="$1"
    local default="${2:-}"

    if [[ ! -f "$AGENT_CONFIG_FILE" ]]; then
        echo "$default"
        return
    fi

    # Handle nested keys (e.g., ai_tool.command)
    if [[ "$key" == *.* ]]; then
        # Split on dot
        local section="${key%%.*}"  # Everything before first dot
        local subkey="${key#*.}"     # Everything after first dot

        # Use awk to find the section and then the subkey
        local value=$(awk -v section="$section:" -v subkey="$subkey:" '
            $0 ~ "^" section {in_section=1; next}
            in_section && /^[^ ]/ {in_section=0}
            in_section && $0 ~ "^[[:space:]]+" subkey {
                sub(/^[[:space:]]*[^:]+:[[:space:]]*/, "")
                gsub(/"/, "")
                print
                exit
            }
        ' "$AGENT_CONFIG_FILE")

        if [[ -z "$value" ]]; then
            echo "$default"
        else
            echo "$value"
        fi
    else
        # Simple top-level key
        local value=$(grep "^${key}: " "$AGENT_CONFIG_FILE" 2>/dev/null | sed 's/^[^:]*: *//' | tr -d '"')

        if [[ -z "$value" ]]; then
            echo "$default"
        else
            echo "$value"
        fi
    fi
}

# Set config value in YAML
set_config_value() {
    local key="$1"
    local value="$2"

    # Create config if doesn't exist
    [[ ! -f "$AGENT_CONFIG_FILE" ]] && init_agent_dirs

    # Check if key exists
    if grep -q "^${key}: " "$AGENT_CONFIG_FILE" 2>/dev/null; then
        # Update existing key
        local tmp_file=$(mktemp)
        sed "s|^${key}:.*|${key}: $value|" "$AGENT_CONFIG_FILE" > "$tmp_file"
        mv "$tmp_file" "$AGENT_CONFIG_FILE"
    else
        # Append new key
        echo "${key}: $value" >> "$AGENT_CONFIG_FILE"
    fi
}

# Configure AI tool interactively
cmd_config() {
    local show_only=false
    local reset=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --show)
                show_only=true
                shift
                ;;
            --reset)
                reset=true
                shift
                ;;
            *)
                die "Unknown argument: $1. Usage: agent config [--show|--reset]"
                ;;
        esac
    done

    # Show current config
    if $show_only; then
        echo -e "${BOLD}Current AI Tool Configuration:${NC}"
        echo ""
        echo -e "  ${CYAN}Command:${NC}        $(get_config_value 'ai_tool.command' 'not configured')"
        echo -e "  ${CYAN}Context Method:${NC} $(get_config_value 'ai_tool.context_method' 'not configured')"
        echo -e "  ${CYAN}Context Flag:${NC}   $(get_config_value 'ai_tool.context_flag' 'n/a')"
        echo -e "  ${CYAN}Context Env:${NC}    $(get_config_value 'ai_tool.context_env' 'n/a')"
        echo -e "  ${CYAN}Pass Directory:${NC} $(get_config_value 'ai_tool.pass_directory' 'true')"
        echo ""
        echo "Edit config: ${GREEN}agent config${NC}"
        echo "Reset config: ${GREEN}agent config --reset${NC}"
        return 0
    fi

    # Reset to defaults
    if $reset; then
        local tmp_file=$(mktemp)
        grep -v "^ai_tool\." "$AGENT_CONFIG_FILE" > "$tmp_file" 2>/dev/null || true
        mv "$tmp_file" "$AGENT_CONFIG_FILE"
        log_success "AI tool configuration reset"
        return 0
    fi

    # Interactive configuration
    log_step "AI Tool Configuration"
    echo ""
    echo "This will configure how 'agent launch' starts your AI coding assistant."
    echo ""

    # Get command
    echo -e "${BOLD}1. Command${NC}"
    echo "   What command launches your AI tool?"
    echo "   Examples: claude-code, cursor, aider, code"
    echo ""
    local current_cmd=$(get_config_value 'ai_tool.command' 'claude-code')
    read -p "   Command [$current_cmd]: " ai_command
    ai_command="${ai_command:-$current_cmd}"

    # Get context method
    echo ""
    echo -e "${BOLD}2. Context Method${NC}"
    echo "   How should context be passed to your tool?"
    echo "   ${CYAN}1)${NC} flag     - Pass via command line flag (e.g., --context context.md)"
    echo "   ${CYAN}2)${NC} env      - Pass via environment variable"
    echo "   ${CYAN}3)${NC} clipboard - Copy to clipboard (you paste manually)"
    echo "   ${CYAN}4)${NC} file     - Create .ai-context file in worktree"
    echo "   ${CYAN}5)${NC} manual   - Just show instructions"
    echo ""
    local current_method=$(get_config_value 'ai_tool.context_method' 'manual')
    read -p "   Method [1-5] ($current_method): " method_choice

    local context_method="$current_method"
    case "${method_choice:-$current_method}" in
        1|flag) context_method="flag" ;;
        2|env) context_method="env" ;;
        3|clipboard) context_method="clipboard" ;;
        4|file) context_method="file" ;;
        5|manual|*) context_method="manual" ;;
    esac

    # Get method-specific config
    local context_flag=""
    local context_env=""

    if [[ "$context_method" == "flag" ]]; then
        echo ""
        echo -e "${BOLD}3. Context Flag${NC}"
        echo "   What flag passes the context file?"
        echo "   Examples: --context, -c, --include"
        echo ""
        local current_flag=$(get_config_value 'ai_tool.context_flag' '--context')
        read -p "   Flag [$current_flag]: " context_flag
        context_flag="${context_flag:-$current_flag}"
    elif [[ "$context_method" == "env" ]]; then
        echo ""
        echo -e "${BOLD}3. Environment Variable${NC}"
        echo "   What environment variable should contain the context?"
        echo "   Examples: AGENT_CONTEXT, AI_CONTEXT"
        echo ""
        local current_env=$(get_config_value 'ai_tool.context_env' 'AGENT_CONTEXT')
        read -p "   Variable name [$current_env]: " context_env
        context_env="${context_env:-$current_env}"
    fi

    # Pass directory?
    echo ""
    echo -e "${BOLD}4. Working Directory${NC}"
    echo "   Should the worktree directory be passed as an argument?"
    echo "   (Usually 'yes' - the tool opens in the worktree)"
    echo ""
    local current_pass_dir=$(get_config_value 'ai_tool.pass_directory' 'true')
    read -p "   Pass directory? [y/N] (${current_pass_dir}): " pass_dir_input
    local pass_directory="${current_pass_dir}"
    case "${pass_dir_input:-${current_pass_dir:0:1}}" in
        y|Y|true|t) pass_directory="true" ;;
        *) pass_directory="false" ;;
    esac

    # Save configuration
    echo ""
    log_step "Saving configuration..."

    # Ensure ai_tool section exists in config
    if ! grep -q "^ai_tool:" "$AGENT_CONFIG_FILE" 2>/dev/null; then
        echo "" >> "$AGENT_CONFIG_FILE"
        echo "# AI Tool Configuration" >> "$AGENT_CONFIG_FILE"
        echo "ai_tool:" >> "$AGENT_CONFIG_FILE"
    fi

    # Save values
    set_config_value "  command" "$ai_command"
    set_config_value "  context_method" "$context_method"
    [[ -n "$context_flag" ]] && set_config_value "  context_flag" "$context_flag"
    [[ -n "$context_env" ]] && set_config_value "  context_env" "$context_env"
    set_config_value "  pass_directory" "$pass_directory"

    log_success "Configuration saved!"
    echo ""

    # Setup AI tool integration (slash commands, etc.)
    setup_ai_tool_integration

    echo ""
    echo -e "${BOLD}Test your configuration:${NC}"
    echo -e "  ${GREEN}agent launch <session-name>${NC}"
}

# Launch AI tool with context
cmd_launch() {
    local session_name=""

    # If no session name provided, try to auto-detect from current directory
    if [[ $# -eq 0 ]]; then
        local git_root=$(get_git_root 2>/dev/null) || die "Not in a git repository"
        local current_dir=$(pwd)

        for session_file in "$AGENT_SESSIONS_DIR"/*.yaml; do
            [[ -e "$session_file" ]] || continue
            local worktree=$(grep "^worktree:" "$session_file" | cut -d' ' -f2-)
            if [[ "$current_dir" == "$worktree"* ]]; then
                session_name=$(grep "^name:" "$session_file" | cut -d' ' -f2-)
                break
            fi
        done

        if [[ -z "$session_name" ]]; then
            die "Not in an agent worktree. Usage: agent launch [session-name]"
        fi

        log_info "Auto-detected session: $session_name"
    else
        session_name="$1"
        session_exists "$session_name" || die "Session '$session_name' not found."
    fi

    # Ensure context files exist
    ensure_session_context "$session_name"

    local worktree=$(get_session_value "$session_name" "worktree")
    local context_dir=$(get_context_dir "$session_name")
    local context_file="$context_dir/context.md"

    # Get AI command from config
    local ai_command=$(get_config_value 'ai_tool.command' 'claude-code')

    log_step "Launching: $ai_command"
    echo -e "  ${DIM}Session:${NC} $session_name"
    echo -e "  ${DIM}Worktree:${NC} $worktree"
    echo -e "  ${DIM}Context:${NC} $context_file"
    echo ""
    echo -e "${BOLD}${GREEN}â†’ Run this command in your agent:${NC} ${CYAN}/agent-instructions${NC}"
    echo ""

    # Change to worktree and launch
    cd "$worktree" || die "Failed to cd to worktree: $worktree"
    exec "$ai_command" "$worktree"
}

# Display help
cmd_help() {
    cat <<EOF
${BOLD}agent${NC} - Multi-Agent Session Manager

${BOLD}USAGE:${NC}
    agent <command> [arguments]

${BOLD}COMMANDS:${NC}
    ${CYAN}new${NC} <session-name> [options]
        Create a new agent session with git worktree
        Options:
            --branch=<name>      Git branch name (default: agent/<session-name>)
            --template=<name>    Session template (default: feature)
            --base=<branch>      Base branch (default: current branch)

    ${CYAN}list${NC}
        List all active agent sessions

    ${CYAN}switch${NC} <session-name>
        Switch to an agent session (cd into worktree)

    ${CYAN}context${NC} <session-name> [--edit]
        View or edit session context
        Options:
            --edit, -e    Open in editor instead of pager

    ${CYAN}sync${NC} <session-name>
        Sync session with upstream changes (fetch + rebase)

    ${CYAN}integrate${NC} <session-name> [options]
        Merge session changes back to base branch (local merge, no PR)
        Options:
            --push         Push base branch after merge
            --close        Close session after successful integration
            --no-ff        Force merge commit (no fast-forward)

    ${CYAN}close${NC} <session-name> [options]
        Close a session and clean up
        Options:
            --delete-branch    Delete the git branch
            --archive          Archive context before closing

    ${CYAN}share-context${NC} <from-session> <to-session> --file=<filename>
        Share context file between sessions

    ${CYAN}lock${NC} <session-name> <reason>
        Lock a session to prevent concurrent edits

    ${CYAN}unlock${NC} <session-name>
        Unlock a session

    ${CYAN}current${NC}
        Show current active session

    ${CYAN}shepherd${NC} [options]
        Review and address PR comments interactively
        Fetches unresolved PR review comments and launches your AI tool
        Options:
            --pr=<number>      PR number (auto-detected from branch if not provided)
            --branch=<name>    Branch name to find PR for
            --dry-run          Show comments without launching agent

    ${CYAN}config${NC} [--show|--reset]
        Configure AI tool integration for agent launch
        Options:
            --show             Show current configuration
            --reset            Reset to defaults
        (Run without options for interactive setup)

    ${CYAN}launch${NC} [session-name]
        Launch your configured AI tool with session context
        Auto-detects session if already in a worktree
        Uses global slash commands for context loading:
          - Claude Code: /agent-instructions in ~/.claude/commands/
          - Codex: /agent-instructions in ~/.codex/prompts/
          - Others: Manual file path provided

    ${CYAN}help${NC}
        Show this help message

${BOLD}EXAMPLES:${NC}
    # Create a new feature session
    agent new auth-feature --branch=feature/oauth

    # List all sessions
    agent list

    # Switch to a session
    agent switch auth-feature

    # View session context
    agent context auth-feature

    # Sync with main branch
    agent sync auth-feature

    # Integrate changes back to base branch
    agent integrate auth-feature              # Local merge only
    agent integrate auth-feature --push       # Merge and push
    agent integrate auth-feature --push --close  # Merge, push, and cleanup

    # Close session when done
    agent close auth-feature --archive --delete-branch

    # Review PR comments and address them
    agent shepherd
    agent shepherd --pr=123
    agent shepherd --auto-apply

    # Configure and launch AI tools
    agent config                    # Interactive setup
    agent config --show             # View current config
    agent launch auth-feature       # Launch AI tool with context

${BOLD}CONFIGURATION:${NC}
    Config file: $AGENT_CONFIG_FILE
    Sessions: $AGENT_SESSIONS_DIR
    Contexts: $AGENT_CONTEXTS_DIR

${BOLD}MORE INFO:${NC}
    See docs/AGENT_WORKFLOWS.md for detailed workflows and examples
EOF
}

# ============================================================================
# Main
# ============================================================================

main() {
    # Initialize directories
    init_agent_dirs

    # Parse command
    local command="${1:-help}"
    shift || true

    case "$command" in
        new)
            cmd_new "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        switch|sw)
            cmd_switch "$@"
            ;;
        context|ctx)
            cmd_context "$@"
            ;;
        sync)
            cmd_sync "$@"
            ;;
        integrate)
            cmd_integrate "$@"
            ;;
        close|rm)
            cmd_close "$@"
            ;;
        share-context)
            cmd_share_context "$@"
            ;;
        lock)
            cmd_lock "$@"
            ;;
        unlock)
            cmd_unlock "$@"
            ;;
        current)
            cmd_current "$@"
            ;;
        shepherd|shep)
            cmd_shepherd "$@"
            ;;
        config|configure)
            cmd_config "$@"
            ;;
        setup)
            # Hidden command to setup AI tool integration
            setup_ai_tool_integration
            log_success "AI tool integration setup complete"
            ;;
        launch|run|start)
            cmd_launch "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            log_error "Unknown command: $command"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
