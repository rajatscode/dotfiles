#!/usr/bin/env bash

# worktree-clean - Clean up stale git worktrees
#
# This script identifies and removes git worktrees that no longer exist
# on disk or are associated with deleted branches.
#
# Usage:
#   worktree-clean [--dry-run] [--force]

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

DRY_RUN=false
FORCE=false

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --help|-h)
            cat <<EOF
worktree-clean - Clean up stale git worktrees

USAGE:
    worktree-clean [options]

OPTIONS:
    --dry-run    Show what would be removed without actually removing
    --force      Don't prompt for confirmation
    --help       Show this help message

DESCRIPTION:
    This script identifies and removes:
    - Worktrees where the directory no longer exists
    - Worktrees associated with deleted branches (optional)

    It will prompt for confirmation before removing anything unless
    --force is specified.
EOF
            exit 0
            ;;
        *)
            log_error "Unknown argument: $1"
            exit 1
            ;;
    esac
done

# Check if we're in a git repo
if ! git rev-parse --git-dir &>/dev/null; then
    log_error "Not in a git repository"
    exit 1
fi

log_info "Scanning for stale worktrees..."

# Get list of worktrees
stale_worktrees=()

while IFS= read -r line; do
    # Parse git worktree list output
    if [[ $line =~ ^worktree\ (.+)$ ]]; then
        current_worktree="${BASH_REMATCH[1]}"
        current_branch=""
    elif [[ $line =~ ^branch\ (.+)$ ]]; then
        current_branch="${BASH_REMATCH[1]}"

        # Check if worktree directory exists
        if [[ ! -d "$current_worktree" ]]; then
            stale_worktrees+=("$current_worktree|MISSING_DIR|$current_branch")
        fi
    fi
done < <(git worktree list --porcelain)

if [[ ${#stale_worktrees[@]} -eq 0 ]]; then
    log_success "No stale worktrees found!"
    exit 0
fi

echo ""
log_warn "Found ${#stale_worktrees[@]} stale worktree(s):"
echo ""

for entry in "${stale_worktrees[@]}"; do
    IFS='|' read -r path reason branch <<< "$entry"
    echo -e "  ${RED}âœ—${NC} $path"
    echo -e "    Reason: $reason"
    echo -e "    Branch: $branch"
    echo ""
done

if $DRY_RUN; then
    log_info "Dry run - no changes made"
    exit 0
fi

# Prompt for confirmation
if ! $FORCE; then
    read -p "Remove these worktrees? [y/N] " -n 1 -r
    echo ""
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Aborted"
        exit 0
    fi
fi

# Remove stale worktrees
for entry in "${stale_worktrees[@]}"; do
    IFS='|' read -r path reason branch <<< "$entry"
    log_info "Removing: $path"
    git worktree remove "$path" --force 2>/dev/null || {
        # If remove fails, try prune
        git worktree prune
    }
done

log_success "Cleanup complete!"
