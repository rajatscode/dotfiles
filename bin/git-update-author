#!/usr/bin/env bash
#
# git-update-author - Update author/committer email and name across ALL commits in ALL branches
#
# This is a DESTRUCTIVE operation that rewrites git history.
# Use this when you need to update author information throughout the repository.
#
# Usage: git update-author --old-email <email> --new-email <email> [options]
#
# Options:
#   --old-email <email>   Email address to replace (required)
#   --new-email <email>   New email address (required)
#   --old-name <name>     Name to replace (optional)
#   --new-name <name>     New name (optional)
#   -f, --force           Skip confirmation prompt
#   -h, --help            Show this help message
#
# Examples:
#   git update-author --old-email old@example.com --new-email new@example.com
#   git update-author --old-email old@example.com --new-email new@example.com --old-name "Old Name" --new-name "New Name"
#   git update-author --old-email old@example.com --new-email new@example.com --force
#
# After running this command, you'll need to force push:
#   git push --force-with-lease origin --all
#

set -e

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_error() {
    echo -e "${RED}ERROR: $1${NC}" >&2
}

print_warning() {
    echo -e "${YELLOW}WARNING: $1${NC}" >&2
}

print_info() {
    echo -e "${BLUE}INFO: $1${NC}"
}

print_success() {
    echo -e "${GREEN}SUCCESS: $1${NC}"
}

# Function to show help
show_help() {
    sed -n '2,/^$/p' "$0" | sed 's/^# \?//'
    exit 0
}

# Parse arguments
FORCE=0
OLD_EMAIL=""
NEW_EMAIL=""
OLD_NAME=""
NEW_NAME=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --old-email)
            OLD_EMAIL="$2"
            shift 2
            ;;
        --new-email)
            NEW_EMAIL="$2"
            shift 2
            ;;
        --old-name)
            OLD_NAME="$2"
            shift 2
            ;;
        --new-name)
            NEW_NAME="$2"
            shift 2
            ;;
        -f|--force)
            FORCE=1
            shift
            ;;
        -h|--help)
            show_help
            ;;
        *)
            print_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Validate input
if [ -z "$OLD_EMAIL" ]; then
    print_error "No old email provided"
    echo ""
    echo "Usage: git update-author --old-email <email> --new-email <email> [options]"
    echo "Use --help for more information"
    exit 1
fi

if [ -z "$NEW_EMAIL" ]; then
    print_error "No new email provided"
    echo ""
    echo "Usage: git update-author --old-email <email> --new-email <email> [options]"
    echo "Use --help for more information"
    exit 1
fi

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    print_error "Not in a git repository"
    exit 1
fi

# Check if there are any commits with the old email
COMMIT_COUNT=$(git log --all --format='%ae' | grep -c "^${OLD_EMAIL}$" || true)
if [ "$COMMIT_COUNT" -eq 0 ]; then
    print_warning "No commits found with email '$OLD_EMAIL'"
    read -p "Continue anyway? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 0
    fi
fi

# Show what commits will be affected
print_info "Found $COMMIT_COUNT commits with email '$OLD_EMAIL'"
echo ""
print_info "Sample of affected commits:"
git log --all --format='%h %ae %an - %s' --author="$OLD_EMAIL" | head -20
if [ "$COMMIT_COUNT" -gt 20 ]; then
    echo "... and $((COMMIT_COUNT - 20)) more commits"
fi
echo ""

# Confirm with user unless --force is specified
if [ $FORCE -eq 0 ]; then
    print_warning "This will PERMANENTLY REWRITE GIT HISTORY!"
    print_warning "All commits with email '$OLD_EMAIL' will be modified."
    echo ""
    echo "Changes to be made:"
    echo "  Old email: $OLD_EMAIL"
    echo "  New email: $NEW_EMAIL"
    if [ -n "$OLD_NAME" ]; then
        echo "  Old name:  $OLD_NAME"
    fi
    if [ -n "$NEW_NAME" ]; then
        echo "  New name:  $NEW_NAME"
    fi
    echo ""
    echo "After this operation:"
    echo "  1. Author and committer info will be updated in all matching commits"
    echo "  2. Commit hashes will change"
    echo "  3. You'll need to force push: git push --force-with-lease --all"
    echo "  4. All collaborators will need to re-clone or reset their branches"
    echo ""
    read -p "Are you sure you want to continue? (yes/N) " -r
    echo
    if [[ ! $REPLY =~ ^[Yy][Ee][Ss]$ ]]; then
        echo "Aborted."
        exit 0
    fi
fi

# Create a backup of all branches
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
BACKUP_TAG="backup-before-update-author-$(date +%Y%m%d-%H%M%S)"
print_info "Creating backup tag: $BACKUP_TAG"
git tag "$BACKUP_TAG"

# Perform the author update
print_info "Updating author information across all branches..."
echo ""

# Build the filter script for git filter-branch
FILTER_SCRIPT="
if [ \"\$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ]; then
    export GIT_AUTHOR_EMAIL=\"$NEW_EMAIL\"
    export GIT_COMMITTER_EMAIL=\"$NEW_EMAIL\"
fi
"

# Add name filtering if specified
if [ -n "$OLD_NAME" ] && [ -n "$NEW_NAME" ]; then
    FILTER_SCRIPT+="
if [ \"\$GIT_AUTHOR_NAME\" = \"$OLD_NAME\" ]; then
    export GIT_AUTHOR_NAME=\"$NEW_NAME\"
    export GIT_COMMITTER_NAME=\"$NEW_NAME\"
fi
"
elif [ -n "$NEW_NAME" ]; then
    # If only new name is specified, update name whenever email matches
    FILTER_SCRIPT+="
if [ \"\$GIT_AUTHOR_EMAIL\" = \"$NEW_EMAIL\" ]; then
    export GIT_AUTHOR_NAME=\"$NEW_NAME\"
    export GIT_COMMITTER_NAME=\"$NEW_NAME\"
fi
"
fi

# Use git filter-branch to rewrite history
if git filter-branch --force --env-filter "$FILTER_SCRIPT" --tag-name-filter cat -- --all; then
    print_success "Author information successfully updated!"

    # Clean up filter-branch refs
    print_info "Cleaning up..."
    rm -rf .git/refs/original/
    git reflog expire --expire=now --all
    git gc --prune=now --aggressive
else
    print_error "git filter-branch failed"
    print_info "Restoring from backup tag..."
    git reset --hard "$BACKUP_TAG"
    exit 1
fi

echo ""
print_success "Git history has been rewritten successfully!"
print_info "Backup tag created: $BACKUP_TAG"
echo ""

# Show summary of changes
print_info "Verification - commits with new email:"
NEW_COMMIT_COUNT=$(git log --all --format='%ae' | grep -c "^${NEW_EMAIL}$" || true)
echo "Found $NEW_COMMIT_COUNT commits with email '$NEW_EMAIL'"
echo ""

print_warning "NEXT STEPS:"
echo "  1. Verify the changes: git log --all --format='%h %ae %an - %s' | grep '$OLD_EMAIL' | head -20"
echo "  2. If satisfied, force push ALL branches: git push --force-with-lease origin --all"
echo "  3. Also push tags if needed: git push --force-with-lease origin --tags"
echo "  4. If something went wrong: git reset --hard $BACKUP_TAG"
echo ""
print_warning "All collaborators will need to re-clone or reset their local branches!"
